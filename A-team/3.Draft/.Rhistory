fit_2=glm(Survived~Pclass + Sex + Age + FamSize , family = binomial(link = 'logit'))
summary(fit_2)
#### sex class interaction
fit_3= glm(Survived~Pclass*Sex + Age + FamSize , family = binomial(link = 'logit'))
summary(fit_3)
#### sex age interaction
fit_9= glm(Survived~Pclass + Sex*Age + FamSize , family = binomial(link = 'logit'))
summary(fit_9)
#### class age interaction
fit_13= glm(Survived~Pclass*Age + Sex + FamSize , family = binomial(link = 'logit'))
summary(fit_13)
#### 3 way
fit_14= glm(Survived~Pclass*Age*Sex + FamSize , family = binomial(link = 'logit'))
summary(fit_14)
#### double 2 ways
fit_15= glm(Survived~Pclass*Age + Age*Sex + FamSize , family = binomial(link = 'logit'))
summary(fit_15)
fit_16= glm(Survived~Pclass*Sex + Age*Sex + FamSize , family = binomial(link = 'logit'))
summary(fit_16)
fit_17= glm(Survived~Pclass*Age + Pclass*Sex + FamSize , family = binomial(link = 'logit'))
summary(fit_17)
######----------------------------------no fam size
#### remove fam size
fit_4=glm(Survived~Pclass + Sex + Age  , family = binomial(link = 'logit'))
summary(fit_4)
#### sex class interaction
fit_5= glm(Survived~Pclass*Sex + Age, family = binomial(link = 'logit'))
summary(fit_5)
#### 3 way interaction
fit_6= glm(Survived~Pclass*Sex*Age, family = binomial(link = 'logit'))
summary(fit_6)
#### sex age interaction
fit_7= glm(Survived~Pclass+Sex*Age, family = binomial(link = 'logit'))
summary(fit_7)
#### class age interaction
fit_8= glm(Survived~Pclass*Age +Sex, family = binomial(link = 'logit'))
summary(fit_8)
#### 2 interactions
fit_10= glm(Survived~Pclass*Sex + Sex*Age, family = binomial(link = 'logit'))
summary(fit_10)
#### 2 interactions
fit_11= glm(Survived~Pclass*Age + Sex*Age, family = binomial(link = 'logit'))
summary(fit_11)
#### 2 interactions
fit_12= glm(Survived~Pclass*Sex + Pclass*Age, family = binomial(link = 'logit'))
summary(fit_12)
anova(fit_4,fit_2, fit_1,  test = "Chisq" )
#### worth adding famsize nothing else
#### therefore use fam size ignore the others
anova(fit_2, fit_3,   test = "Chisq" )   #### sex class interaction looks good
anova(fit_2, fit_9,   test = "Chisq" )    #### sex age interaction also doesn't look bad
anova(fit_2, fit_13, test = "Chisq")      #### class age is out
##### 3-way doesn't make sense but sex class + age class might  ie fit 17
anova(fit_2, fit_3, fit_17,   test = "Chisq" )  #### says nope
anova(fit_2, fit_9, fit_17,   test = "Chisq" )  #### says yes
#### seems like fit_3 is the one
AIC(fit_4, fit_2, fit_1, fit_3, fit_9, fit_13, fit_17)
AIC(fit_1, fit_2, fit_3, fit_4, fit_5, fit_6, fit_7, fit_8,fit_9, fit_10)
AIC(fit_11, fit_12, fit_13, fit_14, fit_15, fit_16, fit_17)
#### AIC backs that up
data2c = read.table('Titanic_SetB.txt', h = TRUE)
names(data2a)
data2c$Survived <- factor(data2c$Survived)
data2c$Pclass <- factor(data2c$Pclass)
data2c$Sex <- factor(data2c$Sex)
data2c$Embarked <- factor(data2c$Embarked)
fitted.results <- predict(model,newdata=data2c[,2:6],type='response')
fitted.results <- predict(fit_3,newdata=data2c[,2:6],type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
misClasificError <- mean(fitted.results != data2c$Survived)
print(paste('Accuracy',1-misClasificError))
fitted.results <- predict(fit_3,newdata=data2c[,2:6],type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
misClasificError <- mean(fitted.results != data2c$Survived)
Accuracy=1-misClasificError
fitted.results
fitted.results
predict(fit_3,newdata=data2c[,2:6],type='response')
fitted_results <- predict(fit_3,newdata=data2c[,2:6],type='response')
fitted_results <- ifelse(fitted_results > 0.5,1,0)
mis_classify <- mean(fitted_results != data2c$Survived)
accuracy=1-mis_classify
accuracy
round(accuracy,4)
proffesional
knitr::opts_chunk$set(echo = TRUE)
fitted_results_1
A=0.00022
B=2.7/10^6
A=0.00022
B=2.7/10^6
c=1.124
d=0.9
mu = function(x)
{
A + B*(c^(x))
}
tpx_ult = function(t,x)
{
exp(-(A*t) - (B/log(c))*(c^x)*((c^t)-1))
}
tpx_select = function(t,age) # Note that parameters can be given *any name
{
if(t %in% 0:2)
{
f1 = (1-d^t)/log(d)
f2 = (c^t-d^t)/log(d/c)
exp(d^(2-t)*(f1*A + f2*B*c^age))
}
else
{
print("Error! Select range out of bound.")
}
}
tpx_ult(t = 5, x = 20)
tpx_ult(5, 20)
tpx_select(1,20)
tpx_select(2,20) #### p8 * q8
tpx_select(5,20) ### can't do this
tpx_select(2,20)*tpx_ult(3,20)   ### need to do this
1 - tpx_ult(5, 20)
fivePtwenty <- tpx_ult(5,20)
1 - fivePtwenty
lifetable = matrix(NA, nrow = 128, ncol=5)    #### just creates the matrix
colnames(lifetable) = c("x", "l[x]", "l[x]+1", "lx+2","x+2")
lifetable[18,4] = 10^5  # start off with 100 000 people at age 20 ultimate
lifetable[18,5] = 20    # set the initial age
lifetable[19,4] = lifetable[18,4]*tpx_ult(1,20)
lifetable[19,5] = 21 # set age 21
for (x in 20:128)
{
lifetable[x,1] = x
lifetable[x,5] = x+2
lifetable[x,4] = lifetable[x-1,4] * tpx_ult(1,x+1)
lifetable[x,2] = lifetable[x,4] / tpx_select(2,x)
lifetable[x,3] = lifetable[x,2] * tpx_select(1,x)
}
View(lifetable)
starting_row = 18 # starting row of the ultimate age from the 'lifetable' matrix
omega = nrow(lifetable) # row of the limiting age of the life table
omega
sur_prob = matrix(NA, nrow = 128, ncol=5) # initialising the matrix
colnames(sur_prob) = c("x", "p[x]", "p[x]+1", "px+2","x+2")
sur_prob[,"x"] = lifetable[,"x"]
sur_prob[,"x+2"] = lifetable[,"x+2"]
i = starting_row
while(i < (omega-1)) # Stop loop to prematurely to avoid out of bound error
{
sur_prob[i,"px+2"] = tpx_ult(1,i+2) # i = 18 initially, making sure we start at age 20
sur_prob[i+2,"p[x]+1"] = lifetable[i+2,"lx+2"]/lifetable[i+2,"l[x]+1"]
sur_prob[i+2,"p[x]"] = lifetable[i+2,"l[x]+1"]/lifetable[i+2,"l[x]"]
i = i + 1
}
sur_prob[i, "px+2"] = tpx_ult(1,i+2) # use current value to i to fill out last couple of values for px
sur_prob[omega, "px+2"] = 0 # set last value to zero
death_prob = 1-sur_prob     # use 'simple' matrix calculations
colnames(death_prob) = c("x", "q[x]", "q[x]+1", "qx+2","x+2")
death_prob[,"x"] = lifetable[,"x"]
death_prob[,"x+2"] = lifetable[,"x+2"]
death_prob2 <- cbind(sur_prob[,'x'],1-sur_prob[,c('p[x]','p[x]+1','px+2')],sur_prob[,'x+2'])
colnames(death_prob2) <- colnames(death_prob)
annuity_tables = function(i = 0.05) # set the default interest rate to be 5%
{
v = 1/(1+i)
annuity_table = matrix(NA,nrow = 128, ncol=5)  # annuity in advanced table
colnames(annuity_table) = c("x", "a[x]", "a[x]+1", "ax+2","x+2")
annuity_table[,"x"] = lifetable[,"x"]
annuity_table[,"x+2"] = lifetable[,"x+2"]
annuity_table[omega,"ax+2"] = 1
# the loop starts from the limiting age to age 20.
# Apply the backward recursion formula
for(i in omega:starting_row) # note difference between starting row and the starting age
{
annuity_table[i-1,"ax+2"] = 1 + v*(sur_prob[i-1,"px+2"]*annuity_table[i,"ax+2"])
annuity_table[i,"a[x]+1"] = 1 + v*(sur_prob[i,"p[x]+1"]*annuity_table[i,"ax+2"])
annuity_table[i,"a[x]"] = 1 + v*(sur_prob[i,"p[x]"]*annuity_table[i,"a[x]+1"])
}
return(annuity_table)
}
five_pecent_ann=annuity_tables()
six_perc_ann = annuity_tables(0.06)
seven_perc_ann = annuity_tables(0.07)
v = (1/1.05)
ann_table_ult = c() # initiate a vector
k = 0
for(j in 20:130)
{
t = seq(0,130-k)
ann_table_ult[j] =  sum(v^(t)*tpx_ult(t,j))
k = k+1
}
an = annuity_tables() # create annuity table with i = 0.05
round(an[18:128,4],4) == round(ann_table_ult[20:130],4)
annuity_table = annuity_tables() # note i = 0.05, the default value
annuity_table[58,"x+2"] # age
annuity_table[58,"ax+2"]
age = 60
which(annuity_table==age,arr.ind=T)
annuity_table[which(annuity_table==age,arr.ind=T)[2,1],"ax+2"]
nEx = function(age, term, sp = F, i = 0.05)        #### sp is selection
{
v = 1/(1+i)
if(sp == T)
{
if(term >= 2)
{
return((v^term)*tpx_select(2,age)*tpx_ult(term-2,age+2))
}
else if(term == 1)
{
return((v^term)*tpx_select(1,age)*tpx_ult(term-1,age+1))
}
else
{
return(1)
}
}
else
{
return((v^term)*tpx_ult(t = term, x = age))
}
}
axn = function(type = "WL", age, term = 0, sp = F, i = 0.05)
{
v = 1/(1+i)
annuity_table = annuity_tables(i) # create annuity table with given interest rate
if(type == "WL") # Whole life
{
if(sp == T)
{
# get value from the annuity table created in the selected age
return(annuity_table[which(annuity_table==age,arr.ind=T)[1,1],"a[x]"])
}
else
{
# get value from the annuity table created in the ultimate age
return(annuity_table[which(annuity_table==age,arr.ind=T)[2,1],"ax+2"])
}
}
else # temporary annuity
{
if(sp == T)
{
if(term == 0)
{
return(0)
}
else if(term == 1)
{
return(1)
}
else # term >= 2
{
# recursive call to axn (whole life(x) - pure endowment*whole life(x+n))
return(axn(age = age, sp = T, i = i) - nEx(age = age, term = term, i = i, sp = T)*axn(age = age+term, i = i))
}
}
else # no select period
{
# recursive call to axn (whole life(x) - pure endowment*whole life(x+n))
return(axn(age = age, i = i) - (nEx(age = age, term = term, i = i)*axn(age = age+term, i = i)))
}
}
}
Axn = function(type = "WL", age, term = 0, sp = F, i = 0.05)
{
v = 1/(1+i)
d = i*v
if(type == "WL") # Whole Life Assurance
{
if(sp == T)
{
return(1 - d*axn(age = age, sp = T, i = i))
}
else
{
return(1 - d*axn(age = age, sp = F, i = i))
}
}
else if(type == "END") # Endowment
{
if(sp == T)
{
return(1 - d*axn(type = "END", age = age, term = term, sp = T, i = i))
}
else
{
return(1 - d*axn(type = "END", age = age, term = term, sp = F, i = i))
}
}
else # term assurance
{
if(sp == T)
{
if(term == 0)
{
return(0) # In fact, Axn should not be defined for a zero term.
}
else if(term == 1)
{
return(v*(1 - tpx_select(1,age)))
}
else #term >= 2
{
# recursive call to Axn (whole life(x) - pure endowment*whole life(x+n))
return(Axn(age = age, sp = T, i = i) - (nEx(age = age, term = term, i = i, sp = T))*Axn(age = age+term, i = i))
}
}
else
{
# recursive call to Axn (whole life(x) - pure endowment*whole life(x+n))
return(Axn(age = age, i = i) - (nEx(age = age, term = term, i = i)*Axn(age = age+term, i = i)))
}
}
}
stdnormalpdf = function(z) (2*pi)^(-1/2)*exp(-z^2/2)
integrate(stdnormalpdf,0,Inf) # From zero to infinity
integrate(stdnormalpdf,0,Inf)$value
integrate(stdnormalpdf,0,1) # From zero to one
integrate(stdnormalpdf,-Inf,1.96)
pnorm(1.96)
i=0.05
v=1/(1+i)
delta = log(1+i)
x=60
integrand  =  function(t) v^t*tpx_ult(t,x)*mu(x+t)
integrate(integrand,0,100)
integrate(integrand,0,120)
integrand  =  function(t) v^t*tpx_ult(t,x)*mu(x+t)
function (f, lower, upper, ..., subdivisions = 100L, rel.tol = .Machine$double.eps^0.25,
abs.tol = rel.tol, stop.on.error = TRUE, keep.xy = FALSE,
aux = NULL)
{
f <- match.fun(f)
ff <- function(x) f(x, ...)
limit <- as.integer(subdivisions)
if (limit < 1L || (abs.tol <= 0 && rel.tol < max(50 * .Machine$double.eps,
5e-29)))
stop("invalid parameter values")
if (is.finite(lower) && is.finite(upper)) {
wk <- .External(C_call_dqags, ff, rho = environment(),
as.double(lower), as.double(upper), as.double(abs.tol),
as.double(rel.tol), limit = limit)
}
else {
if (is.na(lower) || is.na(upper))
stop("a limit is missing")
if (is.finite(lower)) {
inf <- 1
bound <- lower
}
else if (is.finite(upper)) {
inf <- -1
bound <- upper
}
else {
inf <- 2
bound <- 0
}
wk <- .External(C_call_dqagi, ff, rho = environment(),
as.double(bound), as.integer(inf), as.double(abs.tol),
as.double(rel.tol), limit = limit)
}
res <- wk[c("value", "abs.error", "subdivisions")]
res$message <- switch(wk$ierr + 1L, "OK", "maximum number of subdivisions reached",
"roundoff error was detected", "extremely bad integrand behaviour",
"roundoff error is detected in the extrapolation table",
"the integral is probably divergent", "the input is invalid")
if (wk$ierr == 6L || (wk$ierr > 0L && stop.on.error))
stop(res$message)
res$call <- match.call()
class(res) <- "integrate"
res
}
integrate(integrand,0,100)
integrate(integrand,0,120)
A_60_bar = integrate(integrand,0,100)$value
A_60 = Axn(type = "WL", age = x) # using function to calculate whole life
c(A_60_bar, sqrt(1+i)*A_60, (i/delta)*A_60)
c(sqrt(1+i)*A_60 - A_60_bar, (i/delta)*A_60 - A_60_bar)
SA = 100000
int = 0.04
A50_20 = Axn(type = "END", age = 50, term = 20, i = int, sp = T)
a50_20 = axn(type = "END", age = 50, term = 20, i = int, sp = T)
premium = (SA*A50_20)/a50_20
print(paste0("The annual Premium is: R", round(premium,2)))
tV = c()
for(t in 0:20)
{
# R starts indexing from 1, hence to get policy value at time 0, we index from time 1
tV[t+1] = ((premium*axn(type = "END", age = 50, term = t, i = int, sp = T)) -
(SA*Axn(type = "TERM", age = 50, term = t, i = int, sp = T)))/
nEx(age = 50, term = t, i = int, sp = T)
}
plot(tV, type = "l", ylab = "Policy Value, tV (in Rands)", xlab = "Time, t")
title("Poliy values for a 20-year Endowment")
SA = 100000
int = 0.06
x = 30
A50_20 = Axn(type = "TERM", age = x, term = n, i = int)
n = 20
a50_20 = axn(type = "END", age = x, term = n, i = int)
premium = (SA*A50_20)/a50_20
print(paste0("The annual Premium is: R", round(premium,2)))
tV = c()
for(t in 0:n)
{
tV[t+1] = ((premium*axn(type = "END", age = x, term = t, i = int)) -
(SA*Axn(type = "TERM", age = x, term = t, i = int)))/
nEx(age = x, term = t, i = int)
}
pol_val = c()
for(t in 0:n)
{
pol_val[t+1] = (SA*Axn(type = "TERM", age = x+t, term = n-t, i = int)) - (premium*axn(type = "END", age = x+t, term = n-t, i = int))
}
round(tV,2) == round(pol_val,2)
plot(tV, type = "l",pch = 19, ylab = "Policy Value, tV (in Rands)", xlab = "Time, t")
title("Poliy values for a 20-year Term Assurance")
for (x in 20:129)
{
i=0.05
v=1/(1+i)
integrand  =  function(t) v^t*tpx_ult(t,x)*mu(x+t)
A_bar[x] = integrate(integrand,0,100)$value
}
A_bar  <- NULL
Axn(type = "WL", 30, term = 0, sp = F, i = (2/1.03))
Axn(type = "WL", 30, term = 0, sp = F, i = (2/103))
x = seq(-3,3, length = 100)
beta = matrix(c(1, 2),2,1)
X = cbind(1,x)
eta = X\%\*\% beta
pi = exp(eta)/(1+exp(eta))
plot(pi~x, type = 'l', col = '#222299')
abline(v = -beta[1]/beta[2],h = 0.5)
eta = X%*% beta
pi = exp(eta)/(1+exp(eta))
plot(pi~x, type = 'l', col = '#222299')
abline(v = -beta[1]/beta[2],h = 0.5)
letters <- vector(A,B,C,D,E)
ff=pnorm(1.575721201)
ff
gg= pnorm(0.3108101366)
gg
ff=pnorm(0.7060948441)
ff
gg= pnorm(1.971005908)
gg
pnorm(1.360902613)
pnorm(0.4153868802)
library("nlmrt")
install.packages("nlmrt")
library("nlmrt")
utils:::menuInstallPkgs()
utils:::menuInstallPkgs()
q()
setwd("~/GitHub/a-team/A-team/3.Draft")
share_data=read.csv("Top40_28Jun2018.csv", header= TRUE, sep=";")
head(share_data)
setwd("~/GitHub/a-team/A-team/3.Draft")
share_data=read.csv("Top40_28Jun2018.csv", header= TRUE, sep=";")
head(share_data)
vignette(optimx)
start=1/40
starting_values <- rep(start, 40)
test_1=c(1,2,3,4,5,6,7,8,9)
test_2=test_1
test_3=test_1
test=cbind(test_1,test_2,test_3)
View(test)
sub_set=test[1:4;]
sub_set=test[1:4,]
View(sub_set)
length=length(share_data)
length
length=nrow(share_data)
length
in_sample=share_data[1:0.8*length,]
in_sample_length=0.8*length
in_sample=share_data[1:in_sample_length,]
out_sample_start=in_sample_length+1
out_sample=share_data[out_sample_start:length,]
View(in_sample)
sequence=seq(from = 2, to = length(in_sample), by = 3)
tail(sequence)
minimax_data=in_sample[:sequence]
minimax_data=in_sample[,sequence]
optimx(starting_values, t(minimax_data)%*%starting_values, lower=0, upper=1,
method=c("Nelder-Mead","BFGS"))
library(optimx)
optimx(starting_values, t(minimax_data)%*%starting_values, lower=0, upper=1,
method=c("Nelder-Mead","BFGS"))
t(minimax_data)%*%starting_values
t(starting_values)%*%minimax_data
t(minimax_data[1,])%*%starting_values
minimax_data[1,]
x=minimax_data[1,]
x
View(x)
x=t(minimax_data[1,])
View(x)
x=t(minimax_data[1,])%*%starting_values
x=(minimax_data[1,])%*%starting_values
t(minimax_data[1,])*starting_values
x=t(minimax_data[1,])%*%matrix(starting_values)
matrix(starting_values)
x=(minimax_data[1,])%*%matrix(starting_values)
minimax_data[1,]
x=(minimax_data[1,])%*%matrix(starting_values)
x=(minimax_data[1,])*matrix(starting_values)
View(x)
